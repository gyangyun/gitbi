## query页面Visual部分处理逻辑

让我分析一下可视化部分的处理逻辑：

1. 前端页面结构 (query.html):
```html
<h2>Visualization</h2>
<div id="echart-note">No data available</div>
<div id="echart-chart" class="hidden">
    <!-- 图表配置表单 -->
    <form id="echart-options" class="pure-form pure-form-stacked bottom-margin">
        <label for="echart-options-type">
            Chart type
            <select id="echart-options-type">
                <option value="scatter">Scatter</option>
                <option value="line" selected>Line</option>
                <option value="bar">Bar</option>
                <option value="heatmap">Heatmap</option>
            </select>
        </label>
        <label for="echart-options-xaxis">X axis<select id="echart-options-xaxis"></select></label>
        <label for="echart-options-yaxis">Y axis<select id="echart-options-yaxis"></select></label>
        <label for="echart-options-zaxis">Z axis<select id="echart-options-zaxis"></select></label>
        <label for="echart-options-group">Group<select id="echart-options-group"></select></label>
        <button id="echart-render" class="pure-button" onclick="make_viz()">Render chart</button>
    </form>
    <!-- 图表容器 -->
    <div id="{{ echart_id }}"></div>
</div>
```

2. 数据流转过程：

a. 查询执行时（routes_execute.py）:
```python
async def execute_route(request):
    try:
        # ... 执行查询 ...
        col_names, rows, duration_ms = query.execute(...)
        
        # 格式化数据
        table = utils.format_htmltable(table_id, col_names, rows, True)
        data_json = utils.get_data_json(col_names, rows)  # 生成图表数据
        
        data = {
            "request": request,
            "table": table,
            "data_json": data_json,  # 图表数据
            "echart_id": echart_id,  # 图表容器ID
            "no_rows": no_rows,
            "duration": duration_ms,
        }
```

b. 数据格式化（utils.py）:
```python
def get_data_json(headers, rows):
    """将数据转换为图表可用的JSON格式"""
    if rows:
        dtypes = tuple(_data_convert(el)[1] for el in rows[0])
    else:
        dtypes = tuple(None for _ in headers)
    headers = tuple(_data_convert(el)[0] for el in headers)
    rows = tuple(tuple(_data_convert(el)[0] for el in row) for row in rows)
    return json.dumps({
        "headings": headers,  # 列名
        "data": rows,        # 数据
        "dtypes": dtypes     # 数据类型
    }, default=str)
```

3. 前端可视化处理（viz.js 和 viz_control.js）:

a. 数据更新监听：
```javascript
chart_el.addEventListener("newdata", (e) => {
    current_data = e.detail.data;
    update_chart_options();  // 更新图表选项
    make_viz();             // 重新渲染图表
});
```

b. 图表选项更新（viz_control.js）:
```javascript
function update_chart_options() {
    // 更新轴选择器的选项
    var select_ids = ['echart-options-xaxis', 'echart-options-yaxis', 'echart-options-zaxis','echart-options-group'];
    var headings = Array.from(document.getElementById(select_ids[0]).getElementsByTagName('option')).map((node) => node.value)
    var new_headings = ['_NONE', ].concat(current_data.headings);
    
    // 如果列名发生变化，更新所有选择器
    if (!array_ident(headings, new_headings)) {
        select_ids.forEach(id => {
            // 更新选择器选项
        });
    }
}
```

c. 图表渲染（viz.js）:
```javascript
function create_viz(current_data, chart_options, chart_el) {
    // 配置坐标轴
    var axis_opts = {
        nameLocation: 'middle',
        nameTextStyle: {padding: 20},
        splitArea: {show: true}
    }
    
    // 获取数据列索引
    chart_options.x_index = current_data.headings.indexOf(chart_options.xaxis);
    chart_options.y_index = current_data.headings.indexOf(chart_options.yaxis);
    chart_options.z_index = current_data.headings.indexOf(chart_options.zaxis);
    chart_options.group_index = current_data.headings.indexOf(chart_options.group);
    
    // 创建ECharts配置
    var echarts_conf = {
        legend: {show: true, top: 20},
        toolbox: {show: true, feature: {saveAsImage: {show: true}}},
        tooltip: {show: true, triggerOn: "mousemove"},
        title: {show: true, text: title},
        xAxis: {...},
        yAxis: {...},
        series: series
    };
    
    // 渲染图表
    var chart = echarts.init(chart_el);
    chart.setOption(echarts_conf);
}
```

整体流程：

1. 当执行查询时：
   - 后端执行SQL查询获取数据
   - 将数据格式化为表格和图表可用的JSON格式
   - 返回给前端

2. 前端收到数据后：
   - 触发图表的 newdata 事件
   - 更新图表配置选项（X轴、Y轴等选择器）
   - 根据当前配置重新渲染图表

3. 用户交互：
   - 用户可以选择图表类型（散点图、折线图、柱状图、热力图）
   - 可以选择X轴、Y轴、Z轴的数据列
   - 可以选择分组字段
   - 点击"Render chart"按钮重新渲染图表

4. 图表保存：
   - 图表配置会随查询一起保存
   - 下次打开查询时会自动加载保存的图表配置

这是一个完整的前后端交互的可视化系统，使用 ECharts 作为图表库，支持多种图表类型和灵活的数据映射。

## Visual部分保存成json的逻辑

让我来分析一下保存图表配置到同名 .json 文件的实现逻辑：

1. 首先，在前端 query.html 中，保存按钮的处理：
```html
<div class="pure-button" hx-post="{{ request.app.url_path_for('query_save_route', db=db) }}"
    hx-vals="js:{data: save_query_format()}" hx-trigger="click" hx-target-error="#htmx-error" hx-swap="innerHTML">
    Save query
</div>
```

2. 在 `code_editor.js` 中，`save_query_format` 函数会包含图表配置：
```javascript
window.save_query_format = function() {
    // ...
    const viz = window.get_chart_options ? JSON.stringify(window.get_chart_options()) : 'null';
    
    return JSON.stringify({
        query: query,
        file: fileName,
        format: format,
        viz: viz,  // 图表配置会被一起发送到后端
        echart_id: echart_id
    });
}
```

让我们看看后端的处理：

Search files...
根据搜索结果，我来解释一下保存SQL同名JSON文件的实现逻辑：

1. 前端发送保存请求：
当用户点击"Save query"按钮时，会调用 `save_query_format()` 函数，该函数会收集：
- SQL模板
- 文件名
- 可视化配置（图表选项）

2. 后端处理保存请求：
在 `app/repo.py` 中的 `save_query` 函数负责保存：
```python
def save_query(user, db, file, query, viz):
    """
    Save query into repo
    file refers to query file name
    """
    path_obj = Path(file)
    assert file == path_obj.name, "Path passed"
    assert (path_obj.suffix in VALID_QUERY_EXTENSIONS), f"Extension not in {str(VALID_QUERY_EXTENSIONS)}"
    
    query_path = f"{db}/{file}"           # SQL文件路径
    viz_path = f"{query_path}.json"       # 自动生成同名的.json文件路径
    
    to_commit = [
        query_path,
        viz_path,
    ]
    
    # 保存SQL文件
    assert _write_file_content(query_path, query), "Writing query content failed"
    # 保存同名的JSON文件（包含可视化配置）
    assert _write_file_content(viz_path, viz), "Writing viz content failed"
    
    # 提交到Git仓库
    _commit(user, "save", to_commit)
    return True
```

3. 读取可视化配置：
当需要读取可视化配置时，使用 `get_query_viz` 函数：
```python
def get_query_viz(state, db, file):
    """
    Gets saved viz for given query
    """
    try:
        viz_path = os.path.join(db, f"{file}.json")
        viz_str = _get_file_content(state, viz_path)
    except:
        viz_str = "null"  # 如果没有配置文件则返回null
    return viz_str
```

整个流程是：
1. 用户在前端配置SQL和可视化选项
2. 点击保存时，前端收集SQL和可视化配置
3. 后端接收到数据后：
   - 将SQL保存为 `.sql` 文件
   - 将可视化配置保存为同名的 `.json` 文件
4. 当再次打开查询时：
   - 加载SQL文件内容
   - 尝试加载同名的JSON文件来恢复可视化配置
   - 如果JSON文件不存在，则使用默认配置

这样就实现了SQL查询和其可视化配置的关联存储。
